<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Worm Game</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #2c3e50;
            font-family: Arial, sans-serif;
        }

        .game-container {
            text-align: center;
        }

        canvas {
            border: 2px solid #ecf0f1;
            background-color: #34495e;
        }

        .score {
            color: #ecf0f1;
            font-size: 24px;
            margin-bottom: 10px;
        }

        .game-over {
            color: #e74c3c;
            font-size: 32px;
            margin-top: 10px;
        }

        .controls {
            color: #bdc3c7;
            margin-top: 10px;
            font-size: 14px;
        }

        .customization {
            margin-bottom: 15px;
            color: #ecf0f1;
        }

        .customization label {
            display: inline-block;
            margin: 0 10px;
            font-size: 14px;
        }

        .customization select,
        .customization input {
            margin-left: 5px;
            padding: 2px 5px;
            border-radius: 3px;
            border: 1px solid #7f8c8d;
            background-color: #34495e;
            color: #ecf0f1;
        }

        .game-mode {
            margin-bottom: 15px;
            color: #ecf0f1;
        }

        .game-mode button {
            margin: 0 5px;
            padding: 8px 15px;
            border: none;
            border-radius: 5px;
            background-color: #3498db;
            color: white;
            cursor: pointer;
            font-size: 14px;
        }

        .game-mode button.active {
            background-color: #2ecc71;
        }

        .game-mode button:hover {
            opacity: 0.8;
        }

        .players-container {
            display: flex;
            justify-content: space-around;
            margin-bottom: 10px;
        }

        .player-info {
            text-align: center;
        }

        .player-score {
            color: #ecf0f1;
            font-size: 18px;
            margin-bottom: 5px;
        }

        .player1 {
            color: #2ecc71;
        }

        .player2 {
            color: #3498db;
        }

        .controls-info {
            color: #bdc3c7;
            margin-top: 10px;
            font-size: 12px;
            line-height: 1.4;
        }
    </style>
</head>

<body>
    <div class="game-container">
        <div class="game-mode">
            <button id="singlePlayer" class="active">Single Player</button>
            <button id="twoPlayer">Two Player</button>
            <button id="coopPlayer">Co-op</button>
        </div>

        <div class="customization">
            <label>Board Size:
                <select id="boardSize">
                    <option value="small">Small (400x300)</option>
                    <option value="medium" selected>Medium (600x400)</option>
                    <option value="large">Large (800x600)</option>
                    <option value="xl">XL (1000x700)</option>
                </select>
            </label>
            <label>Difficulty:
                <select id="difficulty">
                    <option value="easy">Easy (Pass through self)</option>
                    <option value="normal" selected>Normal (Self collision)</option>
                </select>
            </label>
            <label>Speed:
                <select id="gameSpeed">
                    <option value="150">Slow</option>
                    <option value="100" selected>Normal</option>
                    <option value="75">Fast</option>
                    <option value="50">Very Fast</option>
                </select>
            </label>
        </div>

        <div class="players-container">
            <div class="player-info">
                <div class="player-score player1">Player 1: <span id="score1">0</span> | Length: <span
                        id="length1">1</span></div>
            </div>
            <div class="player-info" id="player2Info" style="display: none;">
                <div class="player-score player2">Player 2: <span id="score2">0</span> | Length: <span
                        id="length2">1</span></div>
            </div>
            <div class="player-info" id="coopInfo" style="display: none;">
                <div class="player-score">Pairs: <span id="coopPairs">0</span> | Time: <span id="coopTime">60</span>s
                </div>
            </div>
        </div>

        <canvas id="gameCanvas" width="600" height="400"></canvas>
        <div class="game-over" id="gameOver" style="display: none;">Game Over! Press Space to restart</div>

        <div class="controls-info">
            <div id="singlePlayerControls">
                <strong>Controls:</strong> Arrow keys to move â€¢ Space to restart<br>
                <strong>Goal:</strong> Eat food to grow and survive as long as possible<br>
                <strong>Easy Mode:</strong> Pass through yourself without dying! Auto-turns at walls!
            </div>
            <div id="twoPlayerControls" style="display: none;">
                <strong>Player 1:</strong> Arrow keys or Gamepad 1<br>
                <strong>Player 2:</strong> WASD keys or Gamepad 2<br>
                <strong>Restart:</strong> Space key<br>
                <strong>Strategic Rules:</strong> You can only bite tail segments if the opponent's remaining length
                would be shorter than your current length. Bite off more than you can chew = you die! Head-to-head
                collision = both die. Win by being 20+ segments longer or outlasting opponent.
            </div>
            <div id="coopControls" style="display: none;">
                <strong>Player 1:</strong> Arrow keys or Gamepad 1 (Green worm)<br>
                <strong>Player 2:</strong> WASD keys or Gamepad 2 (Blue worm)<br>
                <strong>Restart:</strong> Space key<br>
                <strong>Cooperative Rules:</strong> Collect matching colored food pairs together! Both green and blue
                food must be eaten before new pairs spawn. Easy mode: worms pass through each other. Normal mode:
                collision = death. Score based on pairs collected within time limit!
            </div>
        </div>
    </div>

    <script>
        // Sound system
        const sounds = {
            eat: null,
            bite: null,
            gameOver: null,
            victory: null
        };

        // Initialize sounds using Web Audio API
        function initSounds() {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();

            // Create pleasant eating sound
            sounds.eat = () => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.1);

                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.1);
            };

            // Create bite sound for worm eating
            sounds.bite = () => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(150, audioContext.currentTime + 0.15);

                gainNode.gain.setValueAtTime(0.08, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.15);
            };

            // Create game over sound
            sounds.gameOver = () => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.3);

                gainNode.gain.setValueAtTime(0.06, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
            };

            // Create victory sound
            sounds.victory = () => {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(523, audioContext.currentTime); // C5
                oscillator.frequency.setValueAtTime(659, audioContext.currentTime + 0.1); // E5
                oscillator.frequency.setValueAtTime(784, audioContext.currentTime + 0.2); // G5

                gainNode.gain.setValueAtTime(0.08, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.4);
            };
        }

        // Play sound safely
        function playSound(soundName) {
            try {
                if (sounds[soundName]) {
                    sounds[soundName]();
                }
            } catch (e) {
                // Silently fail if audio context issues
            }
        }

        // Game elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameSpeedSelect = document.getElementById('gameSpeed');
        const boardSizeSelect = document.getElementById('boardSize');
        const difficultySelect = document.getElementById('difficulty');
        const gameOverElement = document.getElementById('gameOver');
        const singlePlayerBtn = document.getElementById('singlePlayer');
        const twoPlayerBtn = document.getElementById('twoPlayer');
        const coopPlayerBtn = document.getElementById('coopPlayer');
        const player2Info = document.getElementById('player2Info');
        const coopInfo = document.getElementById('coopInfo');
        const singlePlayerControls = document.getElementById('singlePlayerControls');
        const twoPlayerControls = document.getElementById('twoPlayerControls');
        const score1Element = document.getElementById('score1');
        const score2Element = document.getElementById('score2');
        const length1Element = document.getElementById('length1');
        const length2Element = document.getElementById('length2');
        const coopPairsElement = document.getElementById('coopPairs');
        const coopTimeElement = document.getElementById('coopTime');

        const gridSize = 20;
        let tileCountX = canvas.width / gridSize;
        let tileCountY = canvas.height / gridSize;

        // Board size configurations
        const boardSizes = {
            small: { width: 400, height: 300 },
            medium: { width: 600, height: 400 },
            large: { width: 800, height: 600 },
            xl: { width: 1000, height: 700 }
        };

        // Game constants
        const GAME_CONSTANTS = {
            WIN_LENGTH_DIFFERENCE: 20,  // Win condition: be 20+ segments longer
            FOOD_TIMER_INTERVAL: 15000, // Add food every 15 seconds
            COOP_ROUND_TIME: 60,        // 60 seconds for coop rounds
            FOOD_SCORE: 10,             // Points for eating food
            BITE_SCORE_MULTIPLIER: 5    // Points per segment when biting opponent
        };

        // Game state
        let gameMode = 'single'; // 'single', 'two', or 'coop'
        let gameRunning = true;
        let gameInterval;
        let foodTimer = null;
        let gameStartTime = 0;
        let gamepads = {};

        // Coop mode variables
        let coopTimer = null;
        let coopTimeLeft = GAME_CONSTANTS.COOP_ROUND_TIME;
        let coopPairsCollected = 0;
        let coopFoodPairs = []; // Array of food pairs that need to be collected together

        // Player data structure
        let players = {
            1: {
                worm: [{ x: 5, y: 10 }],
                dx: 1,
                dy: 0,
                score: 0,
                color: '#2ecc71',
                inputBuffer: null,
                alive: true
            },
            2: {
                worm: [{ x: 25, y: 10 }],
                dx: -1,
                dy: 0,
                score: 0,
                color: '#3498db',
                inputBuffer: null,
                alive: true
            }
        };

        let food = [];

        // Generate random food position
        function randomFood() {
            let newFood;
            let validPosition = false;

            while (!validPosition) {
                newFood = {
                    x: Math.floor(Math.random() * tileCountX),
                    y: Math.floor(Math.random() * tileCountY)
                };

                validPosition = true;
                // Check if food spawns on any worm
                for (let playerId in players) {
                    if (!players[playerId].alive) continue;
                    for (let segment of players[playerId].worm) {
                        if (segment.x === newFood.x && segment.y === newFood.y) {
                            validPosition = false;
                            break;
                        }
                    }
                    if (!validPosition) break;
                }
            }

            return newFood;
        }

        // Initialize food - start with 2 food items
        function initFood() {
            food = [];
            coopFoodPairs = [];

            if (gameMode === 'coop') {
                // Create colored food pairs for coop mode
                initCoopFoodPairs();
            } else {
                // Regular food for other modes
                food.push(randomFood());
                food.push(randomFood());
            }
        }

        // Initialize cooperative food pairs
        function initCoopFoodPairs() {
            const pair = {
                green: { ...randomFood(), color: '#2ecc71', eaten: false },
                blue: { ...randomFood(), color: '#3498db', eaten: false }
            };
            coopFoodPairs.push(pair);
        }

        // Add new coop food pair
        function addCoopFoodPair() {
            if (gameMode === 'coop') {
                initCoopFoodPairs();
            }
        }

        // Add more food every 15 seconds
        function addFood() {
            food.push(randomFood());
        }

        // Start food timer
        function startFoodTimer() {
            if (foodTimer) {
                clearInterval(foodTimer);
            }
            gameStartTime = Date.now();
            foodTimer = setInterval(addFood, GAME_CONSTANTS.FOOD_TIMER_INTERVAL);
        }

        // Stop food timer
        function stopFoodTimer() {
            if (foodTimer) {
                clearInterval(foodTimer);
                foodTimer = null;
            }
        }

        // Draw worm segment
        function drawWormSegment(x, y, color, isHead = false) {
            const segX = x * gridSize;
            const segY = y * gridSize;
            const size = gridSize - 2;

            ctx.fillStyle = color;
            ctx.fillRect(segX, segY, size, size);

            if (isHead) {
                // Draw eyes for head
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(segX + 3, segY + 3, 3, 3);
                ctx.fillRect(segX + size - 6, segY + 3, 3, 3);
            }
        }

        // Draw game elements
        function drawGame() {
            // Clear canvas
            ctx.fillStyle = '#34495e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw center line in two-player mode
            if (gameMode === 'two') {
                ctx.strokeStyle = '#7f8c8d';
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(canvas.width / 2, 0);
                ctx.lineTo(canvas.width / 2, canvas.height);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw worms
            for (let playerId in players) {
                if (!players[playerId].alive) continue;
                const player = players[playerId];

                for (let i = 0; i < player.worm.length; i++) {
                    const segment = player.worm[i];
                    drawWormSegment(segment.x, segment.y, player.color, i === 0);
                }
            }

            // Draw food
            if (gameMode === 'coop') {
                // Draw colored food pairs for coop mode
                for (let pair of coopFoodPairs) {
                    if (!pair.green.eaten) {
                        ctx.fillStyle = pair.green.color;
                        ctx.fillRect(pair.green.x * gridSize, pair.green.y * gridSize, gridSize - 2, gridSize - 2);
                    }
                    if (!pair.blue.eaten) {
                        ctx.fillStyle = pair.blue.color;
                        ctx.fillRect(pair.blue.x * gridSize, pair.blue.y * gridSize, gridSize - 2, gridSize - 2);
                    }
                }
            } else {
                // Regular red food for other modes
                ctx.fillStyle = '#e74c3c';
                for (let f of food) {
                    ctx.fillRect(f.x * gridSize, f.y * gridSize, gridSize - 2, gridSize - 2);
                }
            }
        }

        // Update player
        function updatePlayer(playerId) {
            const player = players[playerId];
            if (!player.alive) return;

            // Process buffered input
            if (player.inputBuffer) {
                const { newDx, newDy } = player.inputBuffer;
                player.dx = newDx;
                player.dy = newDy;
                player.inputBuffer = null;
            }

            const head = {
                x: player.worm[0].x + player.dx,
                y: player.worm[0].y + player.dy
            };

            // Check wall collision
            if (head.x < 0 || head.x >= tileCountX || head.y < 0 || head.y >= tileCountY) {
                if (difficultySelect.value === 'easy') {
                    // Auto-turn in easy mode - find the best direction
                    const possibleDirections = [];

                    // Check all four directions for validity
                    const directions = [
                        { dx: 0, dy: -1, name: 'up' },    // Up
                        { dx: 0, dy: 1, name: 'down' },   // Down
                        { dx: -1, dy: 0, name: 'left' },  // Left
                        { dx: 1, dy: 0, name: 'right' }   // Right
                    ];

                    for (let dir of directions) {
                        // Don't reverse direction
                        if (dir.dx === -player.dx && dir.dy === -player.dy) continue;

                        const testHead = {
                            x: player.worm[0].x + dir.dx,
                            y: player.worm[0].y + dir.dy
                        };

                        // Check if this direction is valid (not hitting walls)
                        if (testHead.x >= 0 && testHead.x < tileCountX &&
                            testHead.y >= 0 && testHead.y < tileCountY) {

                            // Check if it would hit self (in easy mode we allow this, but prefer not to)
                            let hitsSelf = false;
                            for (let segment of player.worm) {
                                if (testHead.x === segment.x && testHead.y === segment.y) {
                                    hitsSelf = true;
                                    break;
                                }
                            }

                            possibleDirections.push({ ...dir, hitsSelf });
                        }
                    }

                    if (possibleDirections.length > 0) {
                        // Prefer directions that don't hit self
                        const safeDirs = possibleDirections.filter(dir => !dir.hitsSelf);
                        const chosenDir = safeDirs.length > 0 ? safeDirs[0] : possibleDirections[0];

                        // Auto-turn to the chosen direction
                        player.dx = chosenDir.dx;
                        player.dy = chosenDir.dy;

                        // Recalculate head position with new direction
                        head.x = player.worm[0].x + player.dx;
                        head.y = player.worm[0].y + player.dy;
                    } else {
                        // No valid directions - this shouldn't happen but just in case
                        player.alive = false;
                        return;
                    }
                } else {
                    // Normal mode - die on wall collision
                    player.alive = false;
                    return;
                }
            }

            // Check self collision (only in normal difficulty)
            if (difficultySelect.value === 'normal') {
                for (let segment of player.worm) {
                    if (head.x === segment.x && head.y === segment.y) {
                        player.alive = false;
                        return;
                    }
                }
            }

            // Check collision with other player
            if (gameMode === 'coop') {
                // Coop mode collision rules
                const otherPlayerId = playerId === '1' ? '2' : '1';
                const otherPlayer = players[otherPlayerId];
                if (otherPlayer.alive) {
                    for (let segment of otherPlayer.worm) {
                        if (head.x === segment.x && head.y === segment.y) {
                            if (difficultySelect.value === 'normal') {
                                // Normal mode: collision = death for both
                                player.alive = false;
                                otherPlayer.alive = false;
                                return;
                            }
                            // Easy mode: pass through each other (no collision)
                            break;
                        }
                    }
                }
            } else if (gameMode === 'two') {
                const otherPlayerId = playerId === '1' ? '2' : '1';
                const otherPlayer = players[otherPlayerId];
                if (otherPlayer.alive) {
                    // Check if hitting other player's head (both die)
                    if (head.x === otherPlayer.worm[0].x && head.y === otherPlayer.worm[0].y) {
                        player.alive = false;
                        otherPlayer.alive = false;
                        return;
                    }

                    // Check if eating other player's body - STRATEGIC RULES
                    for (let i = 1; i < otherPlayer.worm.length; i++) {
                        if (head.x === otherPlayer.worm[i].x && head.y === otherPlayer.worm[i].y) {
                            const eatenSegments = otherPlayer.worm.length - i;
                            const remainingOpponentLength = i; // Length after eating
                            const currentPlayerLength = player.worm.length;

                            // STRATEGIC RULE: Can only eat if opponent's eatenSegments < your current length
                            if (eatenSegments >= currentPlayerLength) {
                                // Tried to bite off more than you can chew - you die!
                                player.alive = false;
                                return;
                            }

                            // Safe to eat - remove the eaten segments
                            otherPlayer.worm = otherPlayer.worm.slice(0, i);

                            // Current player grows by the number of eaten segments
                            player.score += eatenSegments * GAME_CONSTANTS.BITE_SCORE_MULTIPLIER;

                            // Add eaten segments to current player
                            for (let j = 0; j < eatenSegments; j++) {
                                player.worm.push(player.worm[player.worm.length - 1]);
                            }

                            playSound('bite');
                            player.worm.unshift(head);
                            return; // Skip normal movement since we already added head
                        }
                    }
                }
            }

            player.worm.unshift(head);

            // Check food collision
            let ateFood = false;

            if (gameMode === 'coop') {
                // Coop mode: check colored food pairs
                for (let pairIndex = 0; pairIndex < coopFoodPairs.length; pairIndex++) {
                    const pair = coopFoodPairs[pairIndex];

                    // Check if green worm (player 1) eats green food
                    if (playerId === '1' && !pair.green.eaten &&
                        head.x === pair.green.x && head.y === pair.green.y) {
                        pair.green.eaten = true;
                        ateFood = true;
                        playSound('eat');
                        break;
                    }

                    // Check if blue worm (player 2) eats blue food
                    if (playerId === '2' && !pair.blue.eaten &&
                        head.x === pair.blue.x && head.y === pair.blue.y) {
                        pair.blue.eaten = true;
                        ateFood = true;
                        playSound('eat');
                        break;
                    }
                }

                // Check if any pairs are complete and remove them
                for (let i = coopFoodPairs.length - 1; i >= 0; i--) {
                    const pair = coopFoodPairs[i];
                    if (pair.green.eaten && pair.blue.eaten) {
                        coopFoodPairs.splice(i, 1);
                        coopPairsCollected++;
                        coopPairsElement.textContent = coopPairsCollected;
                        // Add new pair
                        addCoopFoodPair();
                        playSound('victory'); // Special sound for completing a pair
                    }
                }
            } else {
                // Regular mode: check red food
                for (let i = 0; i < food.length; i++) {
                    if (head.x === food[i].x && head.y === food[i].y) {
                        player.score += GAME_CONSTANTS.FOOD_SCORE;
                        food[i] = randomFood();
                        ateFood = true;
                        playSound('eat');
                        break;
                    }
                }
            }

            if (!ateFood) {
                player.worm.pop();
            }
        }

        // Start coop timer
        function startCoopTimer() {
            if (coopTimer) {
                clearInterval(coopTimer);
            }
            coopTimeLeft = GAME_CONSTANTS.COOP_ROUND_TIME;
            coopPairsCollected = 0;
            coopTimeElement.textContent = coopTimeLeft;
            coopPairsElement.textContent = coopPairsCollected;

            coopTimer = setInterval(() => {
                coopTimeLeft--;
                coopTimeElement.textContent = coopTimeLeft;

                if (coopTimeLeft <= 0) {
                    gameOver('coop', 'time');
                }
            }, 1000);
        }

        // Stop coop timer
        function stopCoopTimer() {
            if (coopTimer) {
                clearInterval(coopTimer);
                coopTimer = null;
            }
        }

        // Update game state
        function update() {
            if (!gameRunning) return;

            // Update gamepads
            updateGamepads();

            // Update players
            updatePlayer('1');
            if (gameMode === 'two' || gameMode === 'coop') {
                updatePlayer('2');
            }

            // Update scores and lengths
            score1Element.textContent = players[1].score;
            length1Element.textContent = players[1].worm.length;
            if (gameMode === 'two') {
                score2Element.textContent = players[2].score;
                length2Element.textContent = players[2].worm.length;
            }

            // Check game over
            if (gameMode === 'single') {
                if (!players[1].alive) {
                    gameOver();
                }
            } else if (gameMode === 'coop') {
                // Coop mode: check if both players are dead
                if (!players[1].alive && !players[2].alive) {
                    gameOver('coop', 'death');
                }
                // Timer-based game over is handled in startCoopTimer
            } else {
                // Two-player mode: check for longest worm win condition
                if (!players[1].alive && !players[2].alive) {
                    // Both dead - longest worm wins
                    if (players[1].worm.length > players[2].worm.length) {
                        gameOver('player1');
                    } else if (players[2].worm.length > players[1].worm.length) {
                        gameOver('player2');
                    } else {
                        gameOver('tie');
                    }
                } else if (!players[1].alive) {
                    gameOver('player2');
                } else if (!players[2].alive) {
                    gameOver('player1');
                }

                // Check if one worm becomes significantly longer (optional win condition)
                const lengthDifference = Math.abs(players[1].worm.length - players[2].worm.length);
                if (lengthDifference >= GAME_CONSTANTS.WIN_LENGTH_DIFFERENCE) {
                    if (players[1].worm.length > players[2].worm.length) {
                        gameOver('player1', 'length');
                    } else {
                        gameOver('player2', 'length');
                    }
                }
            }
        }
        

        // Change board size
        function changeBoardSize() {
            const selectedSize = boardSizeSelect.value;
            const size = boardSizes[selectedSize];

            canvas.width = size.width;
            canvas.height = size.height;
            tileCountX = canvas.width / gridSize;
            tileCountY = canvas.height / gridSize;

            restart();
        }

        // Game over
        function gameOver(winner = null, reason = null) {
            gameRunning = false;
            stopFoodTimer(); // Stop adding more food when game ends
            stopCoopTimer(); // Stop coop timer if running
            let message = 'Game Over! Press Space to restart';

            if (winner === 'coop') {
                if (reason === 'time') {
                    message = `Time's Up! Collected ${coopPairsCollected} pairs! Press Space to restart`;
                } else if (reason === 'death') {
                    message = `Both worms died! Collected ${coopPairsCollected} pairs! Press Space to restart`;
                }
                playSound('gameOver');
            } else if (winner === 'player1') {
                message = reason === 'length' ?
                    `Player 1 Wins by Length (${players[1].worm.length})! Press Space to restart` :
                    'Player 1 Wins! Press Space to restart';
                playSound('victory');
            } else if (winner === 'player2') {
                message = reason === 'length' ?
                    `Player 2 Wins by Length (${players[2].worm.length})! Press Space to restart` :
                    'Player 2 Wins! Press Space to restart';
                playSound('victory');
            } else if (winner === 'tie') {
                message = 'Tie Game! Press Space to restart';
                playSound('gameOver');
            } else {
                playSound('gameOver');
            }

            gameOverElement.textContent = message;
            gameOverElement.style.display = 'block';
        }

        // Restart game
        function restart() {
            stopFoodTimer(); // Stop any existing food timer

            players[1] = {
                worm: [{ x: 5, y: 10 }],
                dx: 1,
                dy: 0,
                score: 0,
                color: '#2ecc71',
                inputBuffer: null,
                alive: true
            };

            players[2] = {
                worm: [{ x: 25, y: 10 }],
                dx: -1,
                dy: 0,
                score: 0,
                color: '#3498db',
                inputBuffer: null,
                alive: true
            };

            gameRunning = true;
            gameOverElement.style.display = 'none';
            initFood();
            startFoodTimer(); // Start the progressive food timer
            startCoopTimer();
            updateGameSpeed();
        }

        // Update game speed
        function updateGameSpeed() {
            if (gameInterval) {
                clearInterval(gameInterval);
            }
            const speed = parseInt(gameSpeedSelect.value);
            gameInterval = setInterval(gameLoop, speed);
        }

        // Gamepad support
        function updateGamepads() {
            const connectedGamepads = navigator.getGamepads();

            for (let i = 0; i < connectedGamepads.length; i++) {
                const gamepad = connectedGamepads[i];
                if (gamepad) {
                    const playerId = i === 0 ? '1' : '2';
                    if (players[playerId] && players[playerId].alive && !players[playerId].inputBuffer) {
                        handleGamepadInput(gamepad, playerId);
                    }
                }
            }
        }

        function handleGamepadInput(gamepad, playerId) {
            const player = players[playerId];
            const threshold = 0.5;

            // D-pad or left stick
            const leftStickX = gamepad.axes[0];
            const leftStickY = gamepad.axes[1];

            if (leftStickY < -threshold && player.dy !== 1) {
                player.inputBuffer = { newDx: 0, newDy: -1 };
            } else if (leftStickY > threshold && player.dy !== -1) {
                player.inputBuffer = { newDx: 0, newDy: 1 };
            } else if (leftStickX < -threshold && player.dx !== 1) {
                player.inputBuffer = { newDx: -1, newDy: 0 };
            } else if (leftStickX > threshold && player.dx !== -1) {
                player.inputBuffer = { newDx: 1, newDy: 0 };
            }
        }

        // Initialize audio on first user interaction
        let audioInitialized = false;
        function initAudioOnInteraction() {
            if (!audioInitialized) {
                initSounds();
                audioInitialized = true;
            }
        }

        // Handle keyboard input
        document.addEventListener('keydown', (e) => {
            initAudioOnInteraction();

            if (!gameRunning && e.code === 'Space') {
                restart();
                return;
            }

            if (!gameRunning) return;

            // Player 1 controls (Arrow keys)
            if (!players[1].inputBuffer && players[1].alive) {
                switch (e.code) {
                    case 'ArrowUp':
                        if (players[1].dy !== 1) {
                            players[1].inputBuffer = { newDx: 0, newDy: -1 };
                        }
                        break;
                    case 'ArrowDown':
                        if (players[1].dy !== -1) {
                            players[1].inputBuffer = { newDx: 0, newDy: 1 };
                        }
                        break;
                    case 'ArrowLeft':
                        if (players[1].dx !== 1) {
                            players[1].inputBuffer = { newDx: -1, newDy: 0 };
                        }
                        break;
                    case 'ArrowRight':
                        if (players[1].dx !== -1) {
                            players[1].inputBuffer = { newDx: 1, newDy: 0 };
                        }
                        break;
                }
            }

            // Player 2 controls (WASD) - only in two-player mode
            if (!players[2].inputBuffer && players[2].alive) {
                switch (e.code) {
                    case 'KeyW':
                        if (players[2].dy !== 1) {
                            players[2].inputBuffer = { newDx: 0, newDy: -1 };
                        }
                        break;
                    case 'KeyS':
                        if (players[2].dy !== -1) {
                            players[2].inputBuffer = { newDx: 0, newDy: 1 };
                        }
                        break;
                    case 'KeyA':
                        if (players[2].dx !== 1) {
                            players[2].inputBuffer = { newDx: -1, newDy: 0 };
                        }
                        break;
                    case 'KeyD':
                        if (players[2].dx !== -1) {
                            players[2].inputBuffer = { newDx: 1, newDy: 0 };
                        }
                        break;
                }
            }
        });

        // Game mode switching functions
        function switchToCoopPlayer() {
            gameMode = 'coop';
            coopPlayerBtn.classList.add('active');
            singlePlayerBtn.classList.remove('active');
            twoPlayerBtn.classList.remove('active');
            player2Info.style.display = 'none';
            coopInfo.style.display = 'block';
            singlePlayerControls.style.display = 'none';
            twoPlayerControls.style.display = 'none';
            document.getElementById('coopControls').style.display = 'block';
            restart();
        }

        function switchToSinglePlayer() {
            gameMode = 'single';
            singlePlayerBtn.classList.add('active');
            twoPlayerBtn.classList.remove('active');
            coopPlayerBtn.classList.remove('active');
            player2Info.style.display = 'none';
            coopInfo.style.display = 'none';
            singlePlayerControls.style.display = 'block';
            twoPlayerControls.style.display = 'none';
            document.getElementById('coopControls').style.display = 'none';
            restart();
        }

        function switchToTwoPlayer() {
            gameMode = 'two';
            twoPlayerBtn.classList.add('active');
            singlePlayerBtn.classList.remove('active');
            coopPlayerBtn.classList.remove('active');
            player2Info.style.display = 'block';
            coopInfo.style.display = 'none';
            singlePlayerControls.style.display = 'none';
            twoPlayerControls.style.display = 'block';
            document.getElementById('coopControls').style.display = 'none';
            restart();
        }

        // Event listeners
        singlePlayerBtn.addEventListener('click', switchToSinglePlayer);
        twoPlayerBtn.addEventListener('click', switchToTwoPlayer);
        coopPlayerBtn.addEventListener('click', switchToCoopPlayer);
        gameSpeedSelect.addEventListener('change', updateGameSpeed);
        boardSizeSelect.addEventListener('change', changeBoardSize);

        // Game loop
        function gameLoop() {
            update();
            drawGame();
        }

        // Initialize game
        initFood();
        updateGameSpeed();
    </script>
</body>

</html>
